---
title: "Untitled"
author: "Jiayu Zhang"
date: "6/9/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(cache = FALSE)
```

# Bin genes by Circ/Exercise Status 

> general data structure  
> differential expressed genes (C0vsC7, C0vsE7, C7vsE7) t-test?


### set up the environment
```{r}
################################################################################
##### Resources and Dependencies ###############################################
################################################################################

# Set the working directory
WD <- '/Volumes/SanDisk64GB/MoTrPAC/'
#setwd(WD)

# Load the dependencies
#source("https://bioconductor.org/biocLite.R")
#BiocManager::install("EnhancedVolcano")
#install.packages("tidyverse")

# Load dependencies
pacs...man <- c("tidyverse","GenomicRanges", "DESeq2","devtools","rafalib","GO.db","vsn","hexbin","ggplot2", "GenomicFeatures","Biostrings","BSgenome","AnnotationHub","plyr","dplyr", "org.Rn.eg.db","pheatmap","sva","formula.tools","pathview","biomaRt", "PROPER","SeqGSEA",'purrr','BioInstaller','RColorBrewer','lubridate', "hms","ggpubr", "ggrepel","genefilter","qvalue","ggfortify","som", "vsn","org.Mm.eg.db","VennDiagram","EBImage","reshape2","xtable","kohonen","som","caret","enrichR","gplots","tiff","splines","gam","EnhancedVolcano")
lapply(pacs...man, FUN = function(X) {
        do.call("library", list(X)) })

################################################################################
######################### Functions ############################################
################################################################################

# Set select
select <- dplyr::select
counts <- DESeq2::counts
map <- purrr::map

# Make the 'not in' operator
################################################################################
'%!in%' <- function(x,y) {
        !('%in%'(x,y))
}
################################################################################

# Capture the Date and Author
################################################################################
date <- format.Date( Sys.Date(), '%Y%m%d' )
auth <- "steep"
################################################################################

## explicit gc, then execute `expr` `n` times w/o explicit gc, return timings
################################################################################
benchmark <- function(n = 1, expr, envir = parent.frame()) {
        expr <- substitute(expr)
        gc()
        map(seq_len(n), ~ system.time(eval(expr, envir), gcFirst = FALSE))
}
################################################################################

# Function to speed up making rows into lists for interation with lapply
################################################################################
f_pmap_aslist <- function(df) {
        purrr::pmap(as.list(df), list)
}
################################################################################

# Function to relabel RNASeq read names to orthologs
###############################################################################################
# mmusculus_gene_ensembl: Mouse genes (GRCm38.p6)
# rnorvegicus_gene_ensembl: Rat genes (Rnor_6.0)
mouse2rat_ortho <- function(x) {
        # Ensure 'x' is a data.frame
        if ( class(x) != "data.frame" ) {
                stop("'x' must be a data frame", class.= FALSE)
        }
        
        # Load requirements
        library(biomaRt)
        library(purrr)
        library(dplyr)
        # Load in annotations
        mart_mm_ens = useMart("ensembl", dataset="mmusculus_gene_ensembl")
        mart_rn_ens = useMart("ensembl", dataset="rnorvegicus_gene_ensembl")
        # Create ortholog table
        ortho_df <- getLDS(attributes=c("ensembl_gene_id","rnorvegicus_homolog_orthology_confidence"),
                           filters="ensembl_gene_id", 
                           values = x$ENSEMBL_MOUSE, 
                           mart=mart_mm_ens,
                           attributesL=c("ensembl_gene_id"), 
                           martL=mart_rn_ens) # Use biomart to get orthologs
        # Filter out any low confidence orthologs and any genes that are not one-to-one orthologs in both directions
        ortho_df <- ortho_df[ortho_df$Rat.orthology.confidence..0.low..1.high. == '1',]
        ortho_df <- ortho_df[!duplicated(ortho_df[,1]),]
        ortho_df <- ortho_df[!duplicated(ortho_df[,3]),]
        names(ortho_df) <- c('ENSEMBL_MOUSE','CONFIDENCE','ENSEMBL_RAT') 
        ortho_df <- ortho_df %>%
                select(-CONFIDENCE)
        
        # Assumes that 'x' has ensembl chicken gene ID's as rownames
        # Ensure that only chicken genes appear in the matrix
        #x <- x[startsWith(rownames(x), "ENSGALG"),]
        # Assign the HUGO symbols to a new column
        x <- left_join(x, ortho_df, by = "ENSEMBL_MOUSE") %>%
                filter(!is.na(ENSEMBL_RAT)) %>%
                mutate(SYMBOL_RAT = mapIds(org.Rn.eg.db, ENSEMBL_RAT, "SYMBOL", "ENSEMBL"))
        x
}
#########################################################################################

# Function to take lowercase strings and convert the first letter to uppercase
################################################################################
firstup <- function(x) {
        substr(x, 1, 1) <- toupper(substr(x, 1, 1))
        x
}
################################################################################

# Sine and cosine functions
################################################################################
SIN <- function(t) sin(2*pi*t/24)
COS <- function(t) cos(2*pi*t/24)
################################################################################
# Extract p-value from linear model TODO: Adjust this code to generate permutation based p-value
################################################################################
lmp <- function (modelobject) {
        if ("lm" %!in% class(modelobject)) stop("Not an object of class 'lm' ")
        f <- summary(modelobject)$fstatistic
        p <- pf(f[1],f[2],f[3],lower.tail=F)
        attributes(p) <- NULL
        return(p)
}
################################################################################
```

Declare Variables
```{r}
#' ## Declare Variables

#+ Declare Variables
################################################################################
#####     Declare Variables     ################################################
################################################################################
# Declare Tissue

# TISSUE: Hypothalamus, Liver, Kidney, Aorta, Adrenal, Brown Adipose, Cortex, Gastrocnemius, Heart, Hippocampus,Lung,Ovaries,PaxGene,Spleen,Testes, White Adipose

# SCN: Suprachiasmatic nucleus -- Hypothalamus
# LIV: Liver
# KID: Kidney
# AOR: Aorta
# SKM: Gastrocnemius
# HAT: Heart
# ADG: Adrenal gland
# BAT: Brown adipose tissue
# WAT: White adipose tissue
# COR: Cortex
# HIP: Hippocampus
# LUNG: Lung
# OVR: Ovaries
# SPL: Spleen
# TES: Testes
TISSUE <- "Adrenal"
TIS <- "ADG"
OUTLIERS <- c('None')
MIS_ID <- c('None')
MIS_ID_Fw2Mc <- c('None')
# Declare Outliers
if(TISSUE == "Kidney"){
        #OUTLIERS <- c('90042016803_SF1','90109015902_SN1')
        #OUTLIERS <- c('90109015902_SN1')
        OUTLIERS <- c('None')
}else if(TISSUE == "Liver"){
        OUTLIERS <- c('90042016803_SF1')
}else if(TISSUE == "Hypothalamus"){
        OUTLIERS <- c('None')
        MIS_ID <- c('90010015402_SF2','90011015402_SF2')
        PRI_VAR <- c("animal.registration.sex")
}else if(TISSUE == "Aorta"){
        OUTLIERS <- c('None')
}else if(TISSUE == "Gastrocnemius"){
        OUTLIERS <- c('ABC')
}else if(TISSUE == "Heart"){
        OUTLIERS <- c('90052015802_SN1')
}else if(TISSUE == "Adrenal"){
        OUTLIERS <- c('ABC')
}else if(TISSUE == "Brown Adipose"){
        OUTLIERS <- c('None')
}else if(TISSUE == "White Adipose"){
        OUTLIERS <- c('90127017003_SF1','90033017003_SF1')
}else if(TISSUE == "Cortex"){
        OUTLIERS <- c('ABC')
}else if(TISSUE == "Hippocampus"){
        OUTLIERS <- c('ABC')
}else if(TISSUE == "Lung"){
        OUTLIERS <- c('ABC')
}else if(TISSUE == "Ovaries"){
        OUTLIERS <- c('ABC')
}else if(TISSUE == "Testes"){
        OUTLIERS <- c('90127016302_SN2','90015016302_SN2')
}else if(TISSUE == "Spleen"){
        OUTLIERS <- c('ABC')
}

#### Tissue:
print(TISSUE)
#### Outliers:
print(OUTLIERS)
print(MIS_ID)
#print(PRI_VAR)
```
Load & Clean Data
```{r}
#' ## Load & Clean Data
#' ##### Data files to load:
#' * Count Matrix and Metadata Table from:
#'     * RNA-Seq from Mt. Sinai
#'         * 3 sequencing batches & metadata
#'     * RNA-Seq from Stanford
#'         * 2 sequencing batches & metadata

#+ Load the Data
################################################################################
#####     Load & Clean Data      ###############################################
################################################################################

# Files last saved in: 20200309_exploration-rna-seq-phase1_steep.R

# Count matrix
count_dat = read.csv(file = paste0(WD,'Data/rna-seq/20200309_rnaseq-countmatrix-pass1a-stanford-sinai_steep.csv'), 
                     header = T, na.strings = "NA", check.names = F) %>% as.matrix()

# Meatdata table
in_file <- paste0(WD,'/data/20200309_rnaseq-meta-pass1a-stanford-sinai_steep.txt')
col_data = read.table(file = paste0(WD,'Data/rna-seq/20200309_rnaseq-meta-pass1a-stanford-sinai_steep.txt'), sep = '\t', header = T, na.strings = "NA", check.names = F)
row.names(col_data) <- col_data$sample_key

#' #### Retrieve Circadian Genes Associated with Tissue
#' Data from Supplementary Table 2 from 1. Yan, J., Wang, H., Liu, Y. & Shao, C. Analysis of gene regulatory networks in the mammalian circadian rhythm. PLoS Comput. Biol. 4, (2008).
#' Downloaded 20200326 by Alec Steep
#' Data previosuly saved in script:

# Circadian Genes 
circ_df = read.table(file = paste0(WD,'Data/library/20200503_rnaseq-circadian-',TIS,'-mouse-rat-ortho_steep-yan.txt'), sep = '\t', header = TRUE) %>% as_tibble()


# Adjust column objects
########################
# To factors
factor_cols <- c("labelid",
                 "vial_label",
                 "animal.registration.sex",
                 "animal.key.exlt4",
                 "X2D_barcode",
                 "BID",
                 "Seq_flowcell_lane",
                 "Seq_flowcell_run",
                 "Seq_end_type",
                 "Lib_UMI_cycle_num",
                 "pid",
                 "acute.test.staffid",
                 "acute.test.siteid",
                 "acute.test.versionnbr",
                 "acute.test.contactshock",
                 "animal.familiarization.staffid",
                 "animal.familiarization.siteid",
                 "animal.familiarization.versionnbr",
                 "animal.familiarization.compliant",
                 "animal.key.protocol",
                 "animal.key.agegroup",
                 "animal.key.batch",
                 "animal.key.intervention",
                 "animal.key.sitename",
                 "animal.registration.staffid",
                 "animal.registration.siteid",
                 "animal.registration.versionnbr",
                 "animal.registration.ratid",
                 "animal.registration.batchnumber",
                 "specimen.collection.bloodcomplete",
                 "specimen.collection.bloodtechid",
                 "specimen.collection.uterustype",
                 "specimen.collection.uterustechid",
                 "specimen.collection.deathtype",
                 "specimen.processing.versionnbr",
                 "specimen.processing.siteid",
                 "bid",
                 "specimen.processing.samplenumber",
                 "specimen.processing.techid",
                 "barcode",
                 "shiptositeid",
                 "receivedcas",
                 "receivestatuscas")
for(fc in factor_cols){
        col_data[[fc]] <- as.factor(col_data[[fc]])
}

# To Dates: 03JUL2018
date_cols <- c("acute.test.d_visit",
               "acute.test.d_start",
               "animal.familiarization.d_visit",
               "animal.familiarization.d_treadmillbegin",
               "animal.familiarization.d_treadmillcomplete",
               "animal.registration.d_visit",
               "animal.registration.d_arrive",
               "animal.registration.d_reverselight",
               "specimen.collection.d_visit",
               "animal.registration.d_birth",
               "Seq_date")
for(dc in date_cols){
        col_data[[dc]] <- ymd(col_data[[dc]])
}

# From Dates: 2/14/2019
date_cols <- c("RNA_extr_date",
               "Lib_prep_date")
for(dc in date_cols){
        col_data[[dc]] <- mdy(col_data[[dc]])
}

# To Times: 10:30:00
time_cols <- c("acute.test.t_complete",
               "specimen.collection.t_anesthesia",
               "specimen.collection.t_bloodstart",
               "specimen.collection.t_bloodstop",
               "specimen.collection.t_edtafill",
               "specimen.collection.uteruscomplete",
               "specimen.collection.t_uterusstart",
               "specimen.collection.t_uterusstop",
               "specimen.collection.t_death",
               "specimen.processing.t_collection",
               "specimen.processing.t_edtaspin",
               "specimen.processing.t_freeze",
               "acute.test.howlongshock",
               "acute.test.t_start")
for(tc in time_cols){
        col_data[[tc]] <- col_data[[tc]] %>% as.character() %>% parse_time()
}

# Set a vector for Exercise/Control Levels and Colors
ec_levels <- c("Exercise - IPE",
               "Exercise - 0.5 hr",
               "Exercise - 1 hr",
               "Exercise - 4 hr",
               "Exercise - 7 hr",
               "Exercise - 24 hr",
               "Exercise - 48 hr",
               "Control - IPE",
               "Control - 7 hr")
ec_colors <- c("gold",
               "darkgoldenrod1",
               "orange",
               "darkorange",
               "darkorange2",
               "darkorange3",
               "darkorange4",
               "steelblue1",
               "steelblue4")
# Releveling factors
col_data$animal.key.anirandgroup <- as.character(col_data$animal.key.anirandgroup)
col_data$animal.key.anirandgroup <- factor(col_data$animal.key.anirandgroup, 
                                           levels = ec_levels)

# Create a variable for time post exercise
col_data <- col_data %>%
  mutate(specimen.collection.t_exercise_hour = case_when(
    animal.key.anirandgroup == 'Control - IPE' ~ -1,
    animal.key.anirandgroup == 'Control - 7 hr' ~ 7,
    animal.key.anirandgroup == 'Exercise - IPE' ~ 0,
    animal.key.anirandgroup == 'Exercise - 0.5 hr' ~ 0.5,
    animal.key.anirandgroup == 'Exercise - 1 hr' ~ 1,
    animal.key.anirandgroup == 'Exercise - 4 hr' ~ 4,
    animal.key.anirandgroup == 'Exercise - 7 hr' ~ 7,
    animal.key.anirandgroup == 'Exercise - 24 hr' ~ 24,
    animal.key.anirandgroup == 'Exercise - 48 hr' ~ 48))

# Take the absolute value of the square root of seconds post exercise (consider negative numbers)
# Make sure to Subtract 1 hour (3600s) from "Control - IPE" groups to account for exercise effect
col_data <- col_data %>%
  mutate(calculated.variables.deathtime_after_acute =
           ifelse(animal.key.anirandgroup == 'Control - IPE', 
                  calculated.variables.deathtime_after_acute - 3600,
                  calculated.variables.deathtime_after_acute))
col_data <- col_data %>%
  mutate(specimen.collection.t_exercise_hour_sqrt = ifelse(
    calculated.variables.deathtime_after_acute < 0, 
    (sqrt(abs(calculated.variables.deathtime_after_acute))/60/60)*(-1), 
    (sqrt(abs(calculated.variables.deathtime_after_acute))/60/60)))
row.names(col_data) <- col_data$sample_key

# Examine histograms
col_data %>%
  filter(animal.key.anirandgroup != 'Control - 7 hr') %>%
  ggplot(aes(x=calculated.variables.deathtime_after_acute)) +
  geom_histogram(bins = 68)
col_data %>%
  filter(animal.key.anirandgroup != 'Control - 7 hr') %>%
  ggplot(aes(x=specimen.collection.t_exercise_hour_sqrt)) +
  geom_histogram(bins = 68)

# Save data as an R objects
################################################################################
# To determine object size
sl <- object.size(count_data)
print(sl, units = "auto") 
# Meta Data
out_file <- paste0(WD,'/data/20200603_rnaseq-meta-pass1a-stanford-sinai-proc_steep.rds')
#saveRDS(col_data, file = out_file)
# Count Data
out_file <- paste0(WD, '/data/20200603_rnaseq-meta-pass1a-stanford-sinai-processed_steep.rds')
#saveRDS(count_data, file = out_file)

# Restore the object
#readRDS(file = "my_data.rds")
```


Place Genes in Genomic Ranges
```{r}
#' ## Place Genes in Genomic Ranges
#' #### Reference Genome and Annotation: Rnor_6.0 (GCA_000001895.4) assembly from Ensembl database (Release 96)
#' Found at: http://uswest.ensembl.org/Rattus_norvegicus/Info/Index.
#' 
#' FASTA: Rattus_norvegicus.Rnor_6.0.dna.toplevel.fa.gz ftp://ftp.ensembl.org/pub/release-96/fasta/rattus_norvegicus/dna/Rattus_norvegicus.Rnor_6.0.dna.toplevel.fa.gz
#' 
#' GTF: Rattus_norvegicus.Rnor_6.0.96.gtf.gz ftp://ftp.ensembl.org/pub/release-96/gtf/rattus_norvegicus/Rattus_norvegicus.Rnor_6.0.96.gtf.gz

#+ Annotate Genes by Chromosome

################################################################################
#####     Annotate Genes by Chromosome       ###################################
################################################################################

### Determine which control samples are male and female
# Get the list of genes on the W chromosome

# Construct your own personal galgal5 reference genome annotation
# Construct from gtf file from Ensembl (same file used in mapping)
ens_gtf <- paste0(WD,'Data/library/Rattus_norvegicus.Rnor_6.0.99.gtf')
Rn_TxDb <- makeTxDbFromGFF(ens_gtf,
                           format=c("gtf"),
                           dataSource="Ensembl_Rattus6_gtf",
                           organism="Rattus norvegicus",
                           taxonomyId=NA,
                           circ_seqs=DEFAULT_CIRC_SEQS,
                           chrominfo=NULL,
                           miRBaseBuild=NA,
                           metadata=NULL)

# Define Female specific sex genes (X chromosome)
# To examine chromosome names
seqlevels(Rn_TxDb)[1:23]
# Extract genes as GRanges object, then names
X_genes_gr <- genes(Rn_TxDb, columns = "TXCHROM", filter = list(tx_chrom=c("X")))
# Collect ensembl gene ids for female specific genes
X_ens_id <- names(X_genes_gr)
# Examine the gene symbols
X_sym <- mapIds(org.Rn.eg.db, names(X_genes_gr), "SYMBOL", "ENSEMBL")
# Extract genes as GRanges object, then names
Y_genes_gr <- genes(Rn_TxDb, columns = "TXCHROM", filter = list(tx_chrom=c("Y")))
# Collect ensembl gene ids for female specific genes
Y_ens_id <- names(Y_genes_gr)
sex_ens_id <- c(X_ens_id,Y_ens_id)
# Examine the gene symbols
Y_sym <- mapIds(org.Rn.eg.db, names(Y_genes_gr), "SYMBOL", "ENSEMBL")
```

Collect Samples of Interest and Normalize
```{r}
#' ## Collect Samples of Interest and Normalize

#+ Collect Samples of Interest and Normalize
################################################################################
#####     Collect Samples of Interest and Normalize      #######################
################################################################################

# Filter Samples (meta)
tod_cols <- col_data %>%
        filter(Tissue == TISSUE) %>%
        filter(sample_key != OUTLIERS) %>%
        filter(!is.na(animal.registration.sex))
rownames(tod_cols) <- tod_cols$sample_key

# Collect samples without NA values in TOD
nona_sams <- tod_cols %>%
        filter(!is.na(specimen.collection.t_death_hour)) %>%
        filter(sample_key != OUTLIERS) %>%
        filter(!is.na(animal.registration.sex)) %>%
        select(sample_key) %>% unlist() %>% as.character()
# Collect tissue specific counts
tod_counts <- count_dat[,nona_sams]

#' #### Sanity Check: Ensure that the metadata rownames are identical to count matrix column names
all(rownames(tod_cols) == colnames(tod_counts))

# Create a design formula and load counts and supporting annotation into an S4 object (DESeq infrastructure)
design = ~1 # Primary variable needs to be last.
title = paste0('Design: ',as.character(design))
dds1 <- DESeqDataSetFromMatrix(countData = tod_counts,
                               colData = tod_cols,
                               design = design)
# Reasoning from:
#citation("PROPER")
#dds
#' #### We remove genes with an average sequencing depth of 10 or less
#' Before Filtering
# dds1
zero_n <- dds1[(rowSums(counts(dds1))/ncol(dds1) < 1), ] %>% 
        nrow() %>% as.character()
reads_n <- 1
keep <- rowSums(counts(dds1))/ncol(dds1) >= reads_n
dds2 <- dds1[keep,]
#' #### Summary of counts and annotation data in a DESeqDataSet after filtering out genes with low sequencing depth
#' TODO: Critic from Jun: Here we are removing features that have a low average expression. This may be removing important features that might have zero counts in some samples and higher counts in specific groups. Consider developing an algorithm that will account for features with expression in n or more samples.
dds2
filter_n <- nrow(dds1) - nrow(dds2) - as.numeric(zero_n)
filter_p <- filter_n/(nrow(dds1) - as.numeric(zero_n))
total_n <- nrow(dds1) - nrow(dds2)

#' ##### Note: Number of genes with average counts between zero and 1 is `r zero_n` but removing reads with less than or equal to `r reads_n` removes an additional `r filter_n` features or removes `r filter_p*100`% of the non-zero reads (total of `r total_n` features removed).
dds <- dds2
#' To see the reads per million for each sample
sort(colSums(assay(dds)))/1e6

# estimateSizeFactors gives us a robust estimate in sequencing depth
dds <- estimateSizeFactors(dds)
#' Size facotrs are generally around 1 (scaled) and calculated using the median and are robust to genes with large read counts
summary(sizeFactors(dds))

rld <- DESeq2::vst(dds,blind = F)
assay(rld) <- limma::removeBatchEffect(assay(rld), rld$animal.registration.sex)
#' Regularized Log (rlog) Transform
# for(n in 1){
#         start_time <- Sys.time()
#         #rld <- DESeq2::rlog(dds)
#         end_time <- Sys.time()
#         print(end_time - start_time)
# }

# This command is redundent, but included for safety
# rs <- rowSums(counts(dds))

#' ## Outlier Detection (By Sample)
```
Outlier Detection (By Sample)

```{r}
#+ Outlier Detection (By Sample)
################################################################################
#####     Outlier Detection (By Sample)     ####################################
################################################################################

# (iii) standardization of the data so that the expression measures for each array have mean 0 and variance 1 across genes.
edata <- scale(t(assay(rld)))

# check that we get mean of 0 and sd of 1
apply(edata , 2, mean)
apply(edata , 2, sd)

# Sometimes genes will demonstrate Median Absolute Deviation (mad) == 0, this causes pcout() to stop. We have manually examined these genes, remove them.
remove_genes <- names(edata.mad[edata.mad == 0])
sig_genes <- res_vp %>%
  filter(SIG == 'SIG') %>%
  select()

remove_genes %in% 


# identify multivariate outliers
x.out <- pcout(edata, makeplot = F)

p=ncol(edata)
n=nrow(edata)





if (any(edata.mad==0))
  stop("More than 50% equal values in one or more variables!")

# Create a dataframe with 3 columns: gene, weight_combined, gene_index
df_out <- data.frame(names(x.out$wfinal), x.out$wfinal) %>% as_tibble()
names(df_out) <- c("sample", 'weight_combined')
df_out$index <- row.names(df_out)

# Arrange the dataframe by weight
df_out <- df_out %>%
  arrange(weight_combined)

# Plot the Outliers by combined weight
df_out %>%
  sample_n(100) %>%
  ggplot(aes(index, weight_combined)) +
  geom_point(alpha = 0.3) +
  geom_hline(yintercept = 0.25)

# Number of strong outlier genes
genes_out <- df_out %>%
  filter(weight_combined < 0.10) %>%
  select(gene) %>% unlist() %>% as.character()
```
Qualitative Assessment of Variance in Tissue
```{r}


#' ## Qualitative Assessment of Variance in Tissue

#+ Qualitative Assessment of Variance in Tissue
################################################################################
#####     Qualitative Assessment of Variance in Tissue      ####################
################################################################################

# Examine the Annotations most strongly associated with PCs
################################################################################
# Function to grab topp 500 variance genes and find correlated variables
###########
cor_PC_1_4 <- function(rld = rld, ntop = 500, intgroups){
  rv <- rowVars(assay(rld))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca <- prcomp(t(assay(rld)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  out_df <- data.frame(matrix(ncol = 3, nrow = 0))
  names(out_df) <- c("PC","Adjusted_R_Sq","Condition")
  for(intgroup in intgroups) {
    intgroup.df <- as.data.frame(colData(rld)[, intgroup, drop = FALSE])
    group <- colData(rld)[[intgroup]]
    d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], PC3 = pca$x[, 3], PC4 = pca$x[, 4],
                    group = group, 
                    intgroup.df, name = colnames(rld))
    # Perform linear model on PC vs
    if(length(unique(group[!is.na(group)])) >=2){
      r2_pc1 <- (lm(PC1 ~ group, data = d) %>% summary())$adj.r.squared
      r2_pc2 <- (lm(PC2 ~ group, data = d) %>% summary())$adj.r.squared
      r2_pc3 <- (lm(PC3 ~ group, data = d) %>% summary())$adj.r.squared
      r2_pc4 <- (lm(PC4 ~ group, data = d) %>% summary())$adj.r.squared
      int_df <- data.frame(PC = 1:4, 
                           Adjusted_R_Sq = c(r2_pc1, r2_pc2,r2_pc3, r2_pc4),
                           Condition = intgroup) %>% as_tibble()
      out_df <- rbind(out_df, int_df)
    }else{
      NA
    }
  }
  out_df %>%
    arrange(desc(Adjusted_R_Sq))
  
}
#########
pc_cor_df <- cor_PC_1_4(rld = rld, ntop = 500, intgroups = names(tod_cols)) %>%
  filter(Adjusted_R_Sq > 0.3) %>%
  arrange(PC)
# Examine Variables of interest for Pcs 1 and 2
# pc_cor_df %>%
#   filter(PC %in% c(1,2))

# Visualize variables in PC's 1 and 2
voi <- pc_cor_df %>%
  filter(PC %in% c(1,2,3,4)) %>%
  select(Condition) %>% unlist() %>% as.character
# Plot the top variables associated with PCs 1 or 2
for( v in voi){
  # Quick investigation of variables
  plot(DESeq2::plotPCA(rld, intgroup =v) +
    guides(color=guide_legend(title=v)))
}
```
Do Tissue Samples cluster by sex.
```{r}
#' #### Do Tissue Samples cluster by sex.
#' Grey samples represent "reference samples".
DESeq2::plotPCA(rld, intgroup ="animal.registration.sex") +
        guides(color=guide_legend(title="Sex"))

PRI_VAR = "animal.registration.sex"

for(pri_var in PRI_VAR){
  pri_var <- "animal.registration.sex"
}

# Examine a labled PCA Plot
################################################################################
#' #### We see just how well duplicate samples correlate regardless of sequencing batch
mypar()
pcaData <- DESeq2::plotPCA(rld, 
                           intgroup=c(pri_var, "sample_key"), 
                           returnData=TRUE, ntop = 500)
percentVar <- round(100 * attr(pcaData, "percentVar"))
#pdf(paste0(WD,"/plots/20200505_rnaseq-",TIS,"-PCA-naive-modeling_steep.pdf"),
#    width = 6, height = 4)
pcaData %>%
  ggplot(aes_string("PC1", "PC2", color=pri_var)) +
        geom_point(size=3) +
        #geom_label_repel(aes(label=sample_key),hjust=0, vjust=0) +
        xlab(paste0("PC1: ",percentVar[1],"% variance")) +
        ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
        #coord_fixed() +
        ggtitle(paste0("PCA of ",TISSUE," Gene Expression:\nNaive Model (~ 1)")) +
        guides(color=guide_legend(title=pri_var)) +
        theme(legend.title=element_blank())
#dev.off()

# Plot Sex-Specific Plots
################################################################################
if(pri_var == "animal.registration.sex"){
  
}
# Variables of interest
male_tis <- (tod_cols %>% 
                     filter(animal.registration.sex == 'Male'))$sample_key %>% 
        as.character()
female_tis <- (tod_cols %>% 
                       filter(animal.registration.sex == 'Female'))$sample_key %>% 
        as.character()
Y_genes <- Y_ens_id[Y_ens_id %in% row.names(assay(rld))]
X_genes <- X_ens_id[X_ens_id %in% row.names(assay(rld))]
sex <- tod_cols$animal.registration.sex
group <- tod_cols$animal.registration.sex

# #### Predict the sex of reference samples (all samples for that matter) by calculating the median expression of genes on the Y chromosome. We should expect a bimodal distribution with males demonstrating significantly higher median expression.
chryexp <- colMeans(assay(rld)[Y_genes,])
chryexp_df <- data.frame("counts" = chryexp)
chryexp_df$sample <- row.names(chryexp_df) %>% as.factor()
chryexp_df <- chryexp_df %>%
        mutate(sex = ifelse(sample %in% male_tis, 'Male', 'Female'))

# Visualize genes on the Y Chromosome
##############################################
# ##### If we create a histogram of the median gene expression values on chromosome Y, we should expect to see a bimodal distribution.
mypar()
chryexp_df %>%
  mutate(plot_labs = ifelse(sample %in% MIS_ID, as.character(sample), '')) %>%
  ggplot(aes(counts, colour = sex)) +
  geom_freqpoly(alpha = 0.6) +
  xlab("Median counts on Y genes (normalized)") +
  ylab("Frequency") +
  ggtitle("Frequency Polyplot & Sample Dotplot: \nSamples plotted by Y gene coverage (median)") +
  geom_dotplot(aes(fill = sex), alpha = 0.5) +
  geom_text_repel(aes(label = plot_labs), box.padding = unit(2, 'lines'), y = 0)
```
DE Test for Sex (Ensure males and females are ordered)
```{r}
# DE Test for Sex (Ensure males and females are ordered)
design = ~ animal.registration.sex # Primary variable needs to be last.
dds_vp <- DESeqDataSetFromMatrix(countData = tod_counts,
                               colData = tod_cols,
                               design = design)
dds_vp <- dds_vp[rowSums(counts(dds_vp))/ncol(dds_vp) >= 1,]
dds_vp <- estimateSizeFactors(dds_vp)
res_vp <- DESeq(dds_vp) %>%
  results(alpha = 0.05,lfcThreshold=0.5)
# Adjust the result dataframe
#res_vp <- res_vp_bk
res_vp <- res_vp %>%
  as.data.frame() %>%
  mutate(ENSEMBL_RAT = row.names(res_vp)) %>%
  mutate(SIG = ifelse((abs(log2FoldChange) >= 0.5 & padj <= 0.05), 'SIG','NS')) %>%
  mutate(CHROM = factor(case_when(ENSEMBL_RAT %in% Y_ens_id ~ "Y",
                           ENSEMBL_RAT %in% X_ens_id ~ "X",
                           ENSEMBL_RAT %!in% c(X_ens_id,Y_ens_id) ~ "AUTO"),
                        levels = c("X", "Y", "AUTO"))) %>%
  arrange(padj) %>%
  as_tibble()

# Generate a volcano plot
res_vp %>%  
  ggplot(aes(log2FoldChange, -log10(padj), color = CHROM)) +
  geom_point(alpha = 0.7, size = 3) +
  geom_hline(yintercept = -log10(0.05), linetype="dashed") +
  geom_vline(xintercept = 0.5, linetype="dashed") +
  geom_vline(xintercept = -0.5, linetype="dashed") +
  ggtitle("DE Genes from Females to Males:
Adjusted p-value <= 0.05; |Log2FC| >= 0.5") +
  ylab(bquote('-'~Log[10]~ 'Adjusted p-value (Bonferroni)')) +
  scale_color_manual(values=c('blue', 'red', 'grey')) +
  theme_bw()

# Generate an accompanying pvalue histogram
res_vp %>%
  ggplot(aes(x = padj, fill = CHROM)) +
  #geom_freqpoly() +
  ggtitle("DE Genes Females to Males (adjusted p-value <= 0.05)") +
  geom_dotplot(aes(x = padj), dotsize = 0.5, alpha = 0.5) +
  geom_vline(xintercept = 0.05, linetype="dashed") +
  xlab('Adjusted p-value (Bonferroni)') +
  ylab("Density") +
  scale_fill_manual(values=c('blue', 'red', 'grey')) +
  theme_bw()

```
Adjust for Between Sex Variance
```{r}


################################################################################
########### Adjust for Between Sex Variance  ###################################
################################################################################

# "To adjust for batch effects, we median- centered the expression levels of each transcript within each batch and confirmed, using the correlation matrices, that the batch effects were removed after the adjustment." 
#~ Li, J. Z. et al. Circadian patterns of gene expression in the human brain and disruption in major depressive disorder. Proc. Natl. Acad. Sci. U. S. A. 110, 9950???9955 (2013).

# Here we have 2 Groups: Control - IPE and Control 7 hr; we'll median center these groups to combine the sexes.
sex_sig_gen = res_vp %>%
  filter(SIG == "SIG") %>%
  select(ENSEMBL_RAT) %>%
  unlist() %>%
  as.character()


M_samples <- col_data %>%
        filter(Tissue == TISSUE) %>%
        filter(!is.na(animal.registration.sex)) %>%
        filter(animal.registration.sex == 'Male') %>%
        filter(sample_key != OUTLIERS) %>%
        #filter(animal.key.anirandgroup %!in% c('Control - 7 hr')) %>%
        select(sample_key) %>% unlist() %>% as.character()
F_samples <- col_data %>%
        filter(Tissue == TISSUE) %>%
        filter(!is.na(animal.registration.sex)) %>%
        filter(sample_key != OUTLIERS) %>%
        filter(animal.registration.sex == 'Female') %>%
        #filter(animal.key.anirandgroup %!in% c('Control - 7 hr')) %>%
        select(sample_key) %>% unlist() %>% as.character()
# Select the counts
M_counts <- assay(rld[, M_samples])
F_counts <- assay(rld[, F_samples])

# Median Center data
# Collects median of the significant genes each row, then subtracts by row medians
M_medians <- apply(M_counts,1,median)
# M_centered <- M_counts - M_medians
F_medians <- apply(F_counts,1,median)
# F_centered <- F_counts - F_medians

for ( i in 1:nrow(M_counts)){
  if (rownames(M_counts)[i] %in% sex_sig_gen){
    M_counts[i,] = M_counts[i,] - M_medians[i]
    F_counts[i,] = F_counts[i,] - F_medians[i]
  }
}
counts_centered <- cbind(M_counts, F_counts)
counts_centered <- counts_centered[, colnames(assay(rld))]
assay(rld) <- counts_centered

#' #### We see just how well duplicate samples correlate regardless of sequencing batch
mypar()
pcaData <- DESeq2::plotPCA(rld, 
                           intgroup=c("animal.key.anirandgroup",
                                      "animal.registration.sex",
                                      "sample_key"), 
                           returnData=TRUE, ntop = 500)
percentVar <- round(100 * attr(pcaData, "percentVar"))
pdf(paste0(WD,"/plots/20200426_rnaseq-",TIS,"-PCA-sexmod-modeling_steep.pdf"),
    width = 6, height = 4)
ggplot(pcaData, aes(PC1, PC2, color=animal.key.anirandgroup,shape=animal.registration.sex)) +
        geom_point(size=3) +
        #geom_label_repel(aes(label=sample_key),hjust=0, vjust=0) +
        xlab(paste0("PC1: ",percentVar[1],"% variance")) +
        ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
        #coord_fixed() +
        ggtitle(paste0("PCA of ",TISSUE," Gene Expression:\ny ~ cohort")) +
        guides(color=guide_legend(title="animal.key.anirandgroup")) +
        scale_color_manual(values=ec_colors) +
        theme(legend.title=element_blank())
#dev.off()

```
Differential expression analysis
```{r}

if (TISSUE %in% c("Adrenal", "Hypothalamus", "Brown Adipose", "Aorta")){
  design = ~ animal.registration.sex + animal.key.anirandgroup # Primary variable needs to be last.
} else {
  design = ~ animal.key.anirandgroup
}

title = paste0('Design: ',as.character(design))
dds1 <- DESeqDataSetFromMatrix(countData = tod_counts,
                               colData = tod_cols,
                               design = design)
# Reasoning from:
#citation("PROPER")
#dds
#' #### We remove genes with an average sequencing depth of 10 or less
#' Before Filtering
# dds1
zero_n <- dds1[(rowSums(counts(dds1))/ncol(dds1) < 1), ] %>% 
        nrow() %>% as.character()
reads_n <- 1
keep <- rowSums(counts(dds1))/ncol(dds1) >= reads_n
dds2 <- dds1[keep,]
#' #### Summary of counts and annotation data in a DESeqDataSet after filtering out genes with low sequencing depth
#' TODO: Critic from Jun: Here we are removing features that have a low average expression. This may be removing important features that might have zero counts in some samples and higher counts in specific groups. Consider developing an algorithm that will account for features with expression in n or more samples.
dds2
filter_n <- nrow(dds1) - nrow(dds2) - as.numeric(zero_n)
filter_p <- filter_n/(nrow(dds1) - as.numeric(zero_n))
total_n <- nrow(dds1) - nrow(dds2)

#' ##### Note: Number of genes with average counts between zero and 1 is `r zero_n` but removing reads with less than or equal to `r reads_n` removes an additional `r filter_n` features or removes `r filter_p*100`% of the non-zero reads (total of `r total_n` features removed).
dds <- dds2
#' To see the reads per million for each sample
sort(colSums(assay(dds)))/1e6
#assay(dds) = counts_centered
dds = DESeq2::DESeq(dds)





c0c7 = results(dds, alpha = 0.05,lfcThreshold=0.5, contrast = c("animal.key.anirandgroup", "Control - IPE", "Control - 7 hr")) 
table(c0c7$padj < 0.05)
hist(c0c7$pvalue[c0c7$baseMean > 1], 
     col="grey", border="white", xlab="pvalue", ylab="frequency", main="")
# data <- plotCounts(dds, gene=which.min(res3$padj), intgroup="animal.key.anirandgroup", returnData=TRUE)
# ggplot(data, aes(x=animal.key.anirandgroup, y=count, col = col_data$hour_death)) +
#   geom_point(position=position_jitter(width=.1,height=0)) +
#   #scale_y_log10() +
#   theme(axis.text.x = element_text(angle = 45))


c0c7_df <- as.data.frame(c0c7)
c0c7_df$ENSEMBL_RAT <- row.names(c0c7_df)
c0c7_de_df <- c0c7_df %>%
        filter(padj <= 0.05) %>%
        filter(baseMean > 1)

# doesn't match any in the database
c0c7_de_df$SYMBOL_RAT <- mapIds(org.Rn.eg.db, c0c7_de_df$ENSEMBL_RAT, "SYMBOL", "ENSEMBL")
c0c7_de_df$ENTREZ_RAT <- mapIds(org.Rn.eg.db, c0c7_de_df$ENSEMBL_RAT, "ENTREZID", "ENSEMBL")

# # Convert gene symbols to mouse orthologs
# # de_df <- rat2mouse_ortho(de_df, column = 'ENSEMBL_RAT')
# 
# #output_n <- de_df$ENSEMBL_RAT %>% unique() %>% length() %>% as.character()
# 
# # COllect the gene symbols
# de_df$SYMBOL_MOUSE <- mapIds(org.Mm.eg.db, de_df$ENSEMBL_MOUSE, "SYMBOL", "ENSEMBL")
# symbol_out <- de_df %>%
#         filter(!is.na(SYMBOL_MOUSE)) %>%
#         select(SYMBOL_MOUSE) %>% unlist() %>% as.character()
c0c7_cols = data.frame(ENSEMBL_RAT = c0c7_de_df$ENSEMBL_RAT, 
                       c0c7_log2FoldChange = c0c7_de_df$log2FoldChange,
                       c0c7_padj = c0c7_de_df$padj,
                       c0c7 = 1)





c7e7 = results(dds, alpha = 0.05,lfcThreshold=0.5, contrast = c("animal.key.anirandgroup", "Control - 7 hr", "Exercise - 7 hr")) 
table(c7e7$padj < 0.05)
hist(c7e7$pvalue[c7e7$baseMean > 1], 
     col="grey", border="white", xlab="pvalue", ylab="frequency", main="")
# data <- plotCounts(dds, gene=which.min(res3$padj), intgroup="animal.key.anirandgroup", returnData=TRUE)
# ggplot(data, aes(x=animal.key.anirandgroup, y=count, col = col_data$hour_death)) +
#   geom_point(position=position_jitter(width=.1,height=0)) +
#   #scale_y_log10() +
#   theme(axis.text.x = element_text(angle = 45))


c7e7_df <- as.data.frame(c7e7)
c7e7_df$ENSEMBL_RAT <- row.names(c7e7_df)
c7e7_de_df <- c7e7_df %>%
        filter(padj <= 0.05) %>%
        filter(baseMean > 1)

c7e7_cols = data.frame(ENSEMBL_RAT = c7e7_de_df$ENSEMBL_RAT, 
                       c7e7_log2FoldChange = c7e7_de_df$log2FoldChange,
                       c7e7_padj = c7e7_de_df$padj,
                       c7e7 = 1)


c0e7 = results(dds, alpha = 0.05,lfcThreshold=0.5, contrast = c("animal.key.anirandgroup", "Control - IPE", "Exercise - 7 hr")) 
table(c0e7$padj < 0.05)
hist(c0e7$pvalue[c0e7$baseMean > 1], 
     col="grey", border="white", xlab="pvalue", ylab="frequency", main="")
# data <- plotCounts(dds, gene=which.min(res3$padj), intgroup="animal.key.anirandgroup", returnData=TRUE)
# ggplot(data, aes(x=animal.key.anirandgroup, y=count, col = col_data$hour_death)) +
#   geom_point(position=position_jitter(width=.1,height=0)) +
#   #scale_y_log10() +
#   theme(axis.text.x = element_text(angle = 45))


c0e7_df <- as.data.frame(c0e7)
c0e7_df$ENSEMBL_RAT <- row.names(c0e7_df)
c0e7_de_df <- c0e7_df %>%
        filter(padj <= 0.05) %>%
        filter(baseMean > 1)

c0e7_cols = data.frame(ENSEMBL_RAT = c0e7_de_df$ENSEMBL_RAT, 
                       c0e7_log2FoldChange = c0e7_de_df$log2FoldChange,
                       c0e7_padj = c0e7_de_df$padj,
                       c0e7 = 1)
```


```{r}
venn.plot <- venn.diagram(
        x = list(
                C0C7 = c0c7_cols$ENSEMBL_RAT,
                C0E7 = c0e7_cols$ENSEMBL_RAT,
                C7E7 = c7e7_cols$ENSEMBL_RAT),
        filename = paste0(WD,"DataAnalysis/20200309_rna-seq_steep/plots/20200618_",TISSUE,"-venn_zhang.tiff"),
        height = 900,
        width = 900,
        resolution = 300,
        col = "black",
        fill = c("dodgerblue", "goldenrod1", "seagreen3"),
        alpha = 0.50,
        #cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
        #        1, 0.8, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
        #cex = c(rep(0.8, 4), rep(0.4,120)),
        #cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
        cat.cex = 0.8,
        cat.fontface = "bold",
        margin = 0.05
)
```





Model CR geness by Time of Death (TOD)
```{r}
################################################################################
#####     Model Circadian Rhythms by Time of Death (TOD)      ##################
################################################################################

tpe_cols = tod_cols[tod_cols$animal.key.anirandgroup != 'Control - 7 hr',] 

tpe_counts = tod_counts[,rownames(tpe_cols)]
# Time of death
TOD <- tpe_cols %>%
        filter(sample_key %in% nona_sams) %>%
        select(specimen.collection.t_death_hour) %>% 
        unlist() %>% as.numeric()

# solve for the three B’s (beta values) by matrix algebra

fit.FR <- function(expr,TOD) { #I’m writing a custom function, it returns PVE (explained below).  We need to tweak the codes to return the beta’s. 

  expr <- as.vector(expr)

  M <- as.matrix(cbind(rep(1,length(TOD)),SIN(TOD),COS(TOD)))

  beta <- solve(t(M)%*%M)%*%(t(M)%*%expr) #this is the code for the formula above, where “solve” is the matrix inversion operation - a nice trick to have.

  SSz <- t(beta) %*% t(M) %*% expr - (sum(expr)^2) / length(expr)

  SSy <- sum(expr^2)-(sum(expr)^2)/ length(expr)

  PVE <- SSz / SSy #The SSz is the variance explained by the fitted function, SSy is the total variance in the data (in this case, the variance of the 55 values for this gene). PVE is Percent Variance Explained.  It measures the goodness of fit.

  return(PVE)

}


#To get pve’s for all genes without looping p times:

#tmp <- apply(tod_counts,1,function(x) fit.FR(x,TOD))

fit.FR.e =  function(expr,TOD) { #I’m writing a custom function, it returns PVE (explained below).  We need to tweak the codes to return the beta’s. 

  expr <- as.vector(expr)

  M <- as.matrix(cbind(rep(1,length(TOD)),SIN(TOD),COS(TOD)))

  beta <- solve(t(M)%*%M)%*%(t(M)%*%expr) #this is the code for the formula above, where “solve” is the matrix inversion operation - a nice trick to have.
  r = expr - M %*% beta 

  
  return(r)

}

tmp = apply(tpe_counts,1,function(x) fit.FR(x,TOD))
myr <- apply(tpe_counts,1,function(x) fit.FR.e(x,TOD))
sin_r = t(myr)
colnames(sin_r) = colnames(tpe_counts)


#If you want to verify it by looping

# for (i in 1:11979) {
# 
# pve2 [i]<- fit.FR(data[i,],TOD)
# 
# }
# 
# It only takes about 1ms per iteration.

 ################################################################################
# Function to calculate the proportion of variance explained
################################################################################
pve.FR<-function(data,TOD) {
        tmp<- apply(data,1,function(x) fit.FR(x,TOD))
        return(tmp)
}
################################################################################

#Some codes for producing an empirical p value for the PVE by permuting TOD many times, say 100 or 1000 times, and compare the observed PVE with the null distribution of simulated PVE’s

p.test.cos<- function(data,TOD,iter,every=10) {

pval <- rep(0,dim(data)[1])

 cat(iter, "permutations in progress\n")

PVE<-pve.FR(data,TOD)

  for(i in 1:iter) {

    new.data<- data[,sample(1:dim(data)[2])]

    tmp.PVE <- pve.FR(new.data,TOD)

    pval <- pval + as.numeric(tmp.PVE >= PVE)

    if(i %% every == 0) cat(every)

    if(i %% (10*every) == 0) cat("\n")

  }

  pval <- pval / iter

}

 

#example of using this function
set.seed(1234)
cos_pval<-p.test.cos(tpe_counts,TOD,iter=100,every=10)

# Get the phase
t<-c(1:24)
sin_phase<- matrix(NA,length(TOD),24)
for (i in 1:24) {
        sin_phase[,i]<- sin(2*pi*(TOD+t[i])/24)
}

# Collect the maximum phase
phase_tod_counts <- matrix(NA,nrow(tpe_counts),24)
for (i in 1:nrow(tpe_counts)) {
        for (j in 1:24) {
                phase_tod_counts[i,j]<-cor(tpe_counts[i,],sin_phase[,j])
        }
}
phase_tod_counts_max <-rep(NA,nrow(tpe_counts))
for (i in 1:nrow(tpe_counts)) {
        phase_tod_counts_max[i] <- c(1:24)[rank(phase_tod_counts[i,])==24]
}

# Store results in a dataframe
sinmod_df <- data.frame("ENSEMBL_RAT" = row.names(tpe_counts),
                        "PVAL_SIN" = cos_pval,
                        "PVE_SIN" = tmp,
                        "PHASE_SIN" = phase_tod_counts_max)
sinmod_df$SYMBOL_RAT = mapIds(org.Rn.eg.db, as.character(sinmod_df$ENSEMBL_RAT), "SYMBOL", "ENSEMBL")
# Filter data frame and arrange
sinmod_df <- sinmod_df %>%
        filter(PVAL_SIN <= 0.05) %>%
        arrange(desc(PVE_SIN))
dim(sinmod_df)

# plot the phase distribution
# d = density(sinmod_df$PHASE_SIN)
# plot(d, main = "Trigonometric Model -- Phase", xlab = "Phase")

sinmod_df$CIRC = ifelse(sinmod_df$ENSEMBL_RAT %in% circ_df$ENSEMBL_RAT, "CIRC", "NON_CIRC") %>% as.factor()
ggplot(sinmod_df, aes(x = PHASE_SIN, color = CIRC)) +
  geom_density() +
  ggtitle(paste0(TISSUE," CIRC/NON_CIRC Comparison in Phase"))
```


Model Exercise Response by time post exercise (use sqrt of the time)
```{r}

################################################################################
#####     Model Exercise Response by Time Post Exercsie      ###################
################################################################################

# Time post exercise (sqrt)
TPE_sqrt <- tpe_cols %>%
        mutate(specimen.collection.t_exercise_hour_sqrt = case_when(
                animal.key.anirandgroup == 'Control - IPE' ~ -1,
                animal.key.anirandgroup == 'Exercise - IPE' ~ 0,
                animal.key.anirandgroup == 'Exercise - 0.5 hr' ~ 0.5,
                animal.key.anirandgroup == 'Exercise - 1 hr' ~ 1,
                animal.key.anirandgroup == 'Exercise - 4 hr' ~ 2,
                animal.key.anirandgroup == 'Exercise - 7 hr' ~ sqrt(7),
                animal.key.anirandgroup == 'Exercise - 24 hr' ~ sqrt(24),
                animal.key.anirandgroup == 'Exercise - 48 hr' ~ -1)) %>%
        select(specimen.collection.t_exercise_hour_sqrt) %>% 
        unlist() %>% as.numeric()




# for here I'll use traditional polynomial methods to see if the 4th order term is necessary
# noticed that lots of genes got NAs in their 4th poly coefficient
# fit.POLY = function(expr, TPE_sqrt){
#   mod = lm(TPE_sqrt ~ poly(expr, degree = 4, raw = T))
#   return(summary(mod)$aliased[5])
# }
# 
# tmp2 <- apply(tod_counts,1,function(x) fit.POLY(x,TPE_sqrt))
# 
# table(tmp2)

# solve for the B’s (beta values) by matrix algebra
ns_mat = ns(TPE_sqrt, df = 4)
# Keep the 4th order for here
fit.POLY.return <- function(expr,TPE) {
        expr <- as.vector(expr) %>% as.numeric()
        M <- as.matrix(cbind(rep(1,length(TPE)),TPE)) 
        #this is the code for the formula above, where “solve” is the matrix 
        #inversion operation - a nice trick to have.
        beta <- solve(t(M)%*%M)%*%(t(M)%*%expr) 
        SSz <- t(beta) %*% t(M) %*% expr - (sum(expr)^2) / length(expr)
        SSy <- sum(expr^2)-(sum(expr)^2)/ length(expr)
        #The SSz is the variance explained by the fitted function, SSy is the total variance in the data (in this case, the variance of the 55 values for this gene). PVE is Percent Variance Explained.  It measures the goodness of fit.
        PVE <- SSz / SSy
        return(PVE)
}


fit.POLY.r <- function(expr,TPE) {
        expr <- as.vector(expr) %>% as.numeric()
        M <- as.matrix(cbind(rep(1,nrow(TPE)),TPE)) 
        #this is the code for the formula above, where “solve” is the matrix 
        #inversion operation - a nice trick to have.
        beta <- solve(t(M)%*%M)%*%(t(M)%*%expr) 
        r = expr - M %*% beta 
        return(r)
}

myr <- apply(tpe_counts,1,function(x) fit.POLY.r(x,ns_mat))
ns_r = t(myr)
colnames(ns_r) = colnames(tpe_counts)
pve4 <- apply(tpe_counts,1,function(x) fit.POLY.return(x,ns_mat))

pve.4<-function(data,TPE) {
        tmp<- apply(data,1,function(x) fit.POLY.return(x,TPE))
        return(tmp)
}
################################################################################
################################################################################
p.test.4 <- function(data,TPE,iter,every=10) {
        pval <- rep(0,dim(data)[1])
        cat(iter, "permutations in progress\n")
        PVE<-pve.4(data,TPE)
        for(i in 1:iter) {
                # Shuffles the samples
                new.data<-data[,sample(1:dim(data)[2])]
                # Calculate the proportion of variance explained
                tmp.PVE <- pve.4(new.data,TPE)
                # Generates a running count of simulated PVE 
                # that are larger or equal to the actual PVE
                pval <- pval + as.numeric(tmp.PVE >= PVE)
                if(i %% every == 0) cat(every)
                if(i %% (10*every) == 0) cat("\n")
        }
        # Calculate the p value by dividing the running count by the number of iterations
        pval <- pval / iter
}
################################################################################

# Calculate the p value empirically with permutation tests: shuffle time points randomly
set.seed(1234)
tpe_counts_pval<-p.test.4(tpe_counts,ns_mat,iter=100,every=10)

# Store results in a dataframe
p4mod_df <- data.frame("ENSEMBL_RAT" = row.names(tod_counts),
                       "PVAL_P4" = tpe_counts_pval,
                       "PVE_P4" = pve4,
                       "CIRC" = ifelse(row.names(tod_counts) %in% circ_hyp$ENSEMBL_RAT, "CIRC", "NON_CIRC"))
p4mod_df$SYMBOL_RAT = mapIds(org.Rn.eg.db, as.character(p4mod_df$ENSEMBL_RAT), "SYMBOL", "ENSEMBL")
# Filter data frame and arrange
p4mod_df <- p4mod_df %>%
        filter(PVAL_P4 <= 0.05) %>%
        arrange(desc(PVE_P4))
dim(p4mod_df)



# # gene by gene visualization
# 
# data <- plotCounts(hypo_dds, gene=rownames(p4mod_df[1,]), intgroup=c("specimen.collection.t_death_hour","animal.key.anirandgroup", "animal.registration.sex"), returnData=TRUE)
# ggplot(data, aes(x=specimen.collection.t_death_hour, y=count, col = animal.key.anirandgroup, shape = animal.registration.sex)) +
#   geom_point(position=position_jitter(width=.1,height=0)) +
#   scale_y_continuous(trans='log2') +
#   theme(axis.text.x = element_text(angle = 45)) +
#     ggtitle(rat_df[i,]$SYMBOL_RAT)
```

SIN MOD 2
```{r}
#example of using this function
tmp = apply(ns_r,1,function(x) fit.FR(x,TOD))


SINMOD2_pval<-p.test.cos(ns_r,TOD,iter=100,every=10)


# Collect the maximum phase
phase_tod_counts2 <- matrix(NA,nrow(tpe_counts),24)
for (i in 1:nrow(tpe_counts)) {
        for (j in 1:24) {
                phase_tod_counts2[i,j]<-cor(ns_r[i,],sin_phase[,j])
        }
}
phase_tod_counts_max2 <-rep(NA,nrow(tpe_counts))
for (i in 1:nrow(tpe_counts)) {
        phase_tod_counts_max2[i] <- c(1:24)[rank(phase_tod_counts2[i,])==24]
}

# Store results in a dataframe
sinmod2_df <- data.frame("ENSEMBL_RAT" = row.names(ns_r),
                        "PVAL_SIN" = SINMOD2_pval,
                        "PVE_SIN" = tmp,
                        "PHASE_SIN" = phase_tod_counts_max2)
sinmod2_df$SYMBOL_RAT = mapIds(org.Rn.eg.db, as.character(sinmod2_df$ENSEMBL_RAT), "SYMBOL", "ENSEMBL")
# Filter data frame and arrange
sinmod2_df <- sinmod2_df %>%
        filter(PVAL_SIN <= 0.05) %>%
        arrange(desc(PVE_SIN))
dim(sinmod2_df)

# plot the phase distribution
# d = density(sinmod_df$PHASE_SIN)
# plot(d, main = "Trigonometric Model -- Phase", xlab = "Phase")

sinmod2_df$CIRC = ifelse(sinmod2_df$ENSEMBL_RAT %in% circ_df$ENSEMBL_RAT, "CIRC", "NON_CIRC") %>% as.factor()
ggplot(sinmod2_df, aes(x = PHASE_SIN, color = CIRC)) +
  geom_density() +
  ggtitle(paste0(TISSUE," CIRC/NON_CIRC Comparison in Phase"))

################################################################################

pve_2 <- apply(sin_r,1,function(x) fit.POLY.return(x,ns_mat))
# Calculate the p value empirically with permutation tests: shuffle time points randomly

tpe_counts_pval2<-p.test.4(sin_r,ns_mat,iter=100,every=10)

# Store results in a dataframe
p4mod2_df <- data.frame("ENSEMBL_RAT" = row.names(sin_r),
                       "PVAL_P4" = tpe_counts_pval2,
                       "PVE_P4" = pve_2,
                       "CIRC" = ifelse(row.names(sin_r) %in% circ_hyp$ENSEMBL_RAT, "CIRC", "NON_CIRC"))
p4mod2_df$SYMBOL_RAT = mapIds(org.Rn.eg.db, as.character(p4mod2_df$ENSEMBL_RAT), "SYMBOL", "ENSEMBL")
# Filter data frame and arrange
p4mod2_df <- p4mod2_df %>%
        filter(PVAL_P4 <= 0.05) %>%
        arrange(desc(PVE_P4))
dim(p4mod2_df)

```


Compare Models

```{r}
# Compare best polynomial model to SIN model
######################################
# Select the shared genes between models
shared_mod_df <- sinmod_df %>%
        inner_join(p4mod_df, by = "ENSEMBL_RAT")

# Generate a venn diagram of the models
# Venn DIagram
venn.plot <- venn.diagram(
        x = list(
                SIN = sinmod_df$ENSEMBL_RAT,
                C0C7 = c0c7_cols$ENSEMBL_RAT,
                CIRC = circ_df$ENSEMBL_RAT),
        filename = paste0(WD,"DataAnalysis/20200309_rna-seq_steep/plots/20200629_",TISSUE,"-p4vssin-venn_zhang.tiff"),
        height = 900,
        width = 900,
        resolution = 300,
        col = "black",
        fill = c("dodgerblue", "goldenrod1", "seagreen3"),
        alpha = 0.50,
        #cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
        #        1, 0.8, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
        #cex = c(rep(0.8, 4), rep(0.4,120)),
        #cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
        cat.cex = 0.8,
        cat.fontface = "bold",
        margin = 0.05
)

venn.plot <- venn.diagram(
        x = list(
                SIN = sinmod_df$ENSEMBL_RAT,
                SIN2 = sinmod2_df$ENSEMBL_RAT,
                CIRC = circ_df$ENSEMBL_RAT),
        filename = paste0(WD,"DataAnalysis/20200309_rna-seq_steep/plots/20200629_",TISSUE,"-sin2vssin-venn_zhang.tiff"),
        height = 900,
        width = 900,
        resolution = 300,
        col = "black",
        fill = c("dodgerblue", "goldenrod1", "seagreen3"),
        alpha = 0.50,
        #cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
        #        1, 0.8, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
        #cex = c(rep(0.8, 4), rep(0.4,120)),
        #cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
        cat.cex = 0.8,
        cat.fontface = "bold",
        margin = 0.05
)


# Generate a scatterplot of the models' PVE's
shared_mod_df %>%
        ggplot(aes(x = PVE_P4, y= PVE_SIN)) +
        geom_point(alpha = 0.3) +
        geom_point(data = )
        xlim(0,1) + ylim(0,1) +
        geom_abline(intercept = 0, slope = 1) +
        ggtitle("All Genes PVE Comparison") +
        xlab("PVE: Polynomial (Degree 4)") +
        ylab("PVE: SIN")
# Supporting violin plot
shared_mod_df %>%
        select(ENSEMBL_RAT, PVE_SIN, PVE_P4) %>%
        gather(MODEL, PVE, -ENSEMBL_RAT) %>%
        ggplot(aes(MODEL,PVE)) +
        geom_violin() +
        geom_boxplot(alpha = 0.1) +
        ggtitle("All Genes PVE Comparison") +
        scale_x_discrete(labels=c("PVE_SIN" = "SIN", 
                                  "PVE_P4" = "Polynomial (Degree 4)")) +
        scale_y_continuous(breaks=seq(0,1,0.2))

```

colored scatterplot of genes
```{r}
# Select the shared genes between models
shared_mod_df <- sinmod_df %>%
        inner_join(p4mod_df, by = "ENSEMBL_RAT") %>%
        left_join(c0c7_cols, by = "ENSEMBL_RAT") %>%
        left_join(c7e7_cols, by = "ENSEMBL_RAT")

# Generate a scatterplot of the models' PVE's
shared_mod_df %>%
        ggplot(aes(x = PVE_P4, y= PVE_SIN)) +
        geom_point(alpha = 0.3) +
        geom_point(data = shared_mod_df[shared_mod_df$c0c7 == 1,], aes(x = PVE_P4, y= PVE_SIN, color = "c0c7_DE")) +
        geom_point(data = shared_mod_df[shared_mod_df$c7e7 == 1,], aes(x = PVE_P4, y= PVE_SIN, color = "c7e7_DE")) +
        xlim(0,1) + ylim(0,1) +
        geom_abline(intercept = 0, slope = 1) +
        geom_abline(intercept = 0.1, slope = 1, linetype = 2) +
        geom_abline(intercept = -0.1, slope = 1, linetype = 2) +
        ggtitle(paste0(TISSUE, " All Genes PVE Comparison")) +
        xlab("PVE: NS (Degree 4)") +
        ylab("PVE: SIN")




```




Draw for CR genes
```{r}
# Visualize the models on CIRC Genes
##############################
shared_mod_circ <- shared_mod_df %>%
        filter(ENSEMBL_RAT %in% circ_hyp$ENSEMBL_RAT) %>%
        mutate(SYMBOL_RAT = SYMBOL_RAT.x) %>%
        select(-SYMBOL_RAT.y, -SYMBOL_RAT.x) %>%
        arrange(desc(PVE_P4))
# Scatterplot
shared_mod_circ %>%
        ggplot(aes(x = PVE_P4, y= PVE_SIN)) +
        geom_point(alpha = 0.3) +
        xlim(0,1) + ylim(0,1) +
        geom_abline(intercept = 0, slope = 1) +
  ggtitle("CR Genes PVE Comparison") +
        xlab("PVE: Polynomial (Degree 4)") +
        ylab("PVE: SIN")
# Supporting violin plot
shared_mod_circ %>%
        select(ENSEMBL_RAT, PVE_SIN, PVE_P4) %>%
        gather(MODEL, PVE, -ENSEMBL_RAT) %>%
        ggplot(aes(MODEL,PVE)) +
        geom_violin() +
        geom_boxplot(alpha = 0.1) +
  ggtitle("CR Genes PVE Comparison") +
        scale_x_discrete(labels=c("PVE_SIN" = "SIN", 
                                  "PVE_P4" = "Polynomial (Degree 4)")) +
        scale_y_continuous(breaks=seq(0,1,0.2))
```


build the output file:
```{r}

outfile <- sinmod_df %>%
        full_join(p4mod_df, by = "ENSEMBL_RAT", suffix = c("_SINMOD", "_NSMOD")) %>%
        full_join(sinmod2_df, by = "ENSEMBL_RAT", suffix = c("_SINMOD", "_SINMOD2")) %>%
        full_join(p4mod2_df, by = "ENSEMBL_RAT", suffix = c("NSMOD", "_NSMOD2")) %>%
        full_join(c0c7_cols, by = "ENSEMBL_RAT") %>%
        full_join(c7e7_cols, by = "ENSEMBL_RAT") %>%
        full_join(c0e7_cols, by = "ENSEMBL_RAT") %>% cbind(tissue = TISSUE)


outfile$c0c7[is.na(outfile$c0c7)] = 0
outfile$c7e7[is.na(outfile$c7e7)] = 0
outfile$c0e7[is.na(outfile$c0e7)] = 0
outfile = cbind(outfile, "inference" = NA)

# for (i in 1:nrow(outfile)) {
#   if (outfile[i,]$c0c7 == 1){
#     if (outfile[i,]$c7e7 == 1){
#       outfile[i,]$inference = "AE"
#     }else if (outfile[i,]$c0e7 == 1){
#       outfile[i,]$inference = "A"
#     } else {
#       outfile[i,]$inference = "C"
#     }
#   } else if (outfile[i,]$c7e7 == 1 & outfile[i,]$c0e7 == 1){
#     outfile[i,]$inference = "E"
#   }
# }
# 
# outfile = outfile[,c(1,5,2,3,4,6)]
```



write table
```{r}
write.table(outfile, file = paste0(WD, "/Data/intermediate/20200629-",TISSUE,"-gene-list_Zhang.txt"), sep = "\t",  row.names = F, quote = FALSE)
```

